import uuid

class CBusinessLogic:

	def __init__(self, config):
		self.configurator = config

	def stripImageRequest(self, packet):
		'''
		tests if the message field contains the strings draw, picture or image
		returns True plus the revised packet
		'''
		#if "#picture" in packet["message"] or "#image" in packet["message"]:
		#	
		#	packet["message"] = packet["message"].replace("#picture", "")
		#	packet["message"] = packet["message"].replace("#image", "")

		keyword_matched = False

		for keyword in self.configurator.getProperty("MESSAGE_IMAGE_TYPE_KEYWORDS"):

			if keyword in packet["message"]:
				keyword_matched = True

		return keyword_matched, packet
	
	def stripConfigRequest(self, packet):
		'''
		tests if the message field contains the string #config
		If so it strips this string out and returns True plus
		the revised packet
		'''
		if "#config" in packet["message"]:

			packet["message"] = packet["message"].replace("#config", "")

			return True, packet

		return False, packet

	def processPacket(self, packet, instructions=None):
		'''
		Test to see if the packet is valid
		if not or special instructions have been give
		flag the packet as special in its type
		'''

		out_packet = packet

		test_result, out_packet = self.stripImageRequest(out_packet)
		if test_result:

			out_packet["type"] = self.configurator.getProperty("MESSAGE_TYPE_IMAGE")

		# TODO: Be careful that the packet doesn't satisfy both conditions

		test_result, out_packet = self.stripConfigRequest(out_packet)
		if test_result:

			out_packet["type"] = self.configurator.getProperty("MESSAGE_TYPE_CONFIG")

		return out_packet		

	def checkPackets(self, packets, instructions=None):

		out_packets = []

		in_direction = True
		if instructions is not None and type(instructions) is dict:
			in_direction = instructions["in"]

		current_packet_number = self.configurator.getProperty("PACKET_NUMBER")
		current_packet_ttl = self.configurator.getProperty("PACKET_TTL")

		for packet in packets:

			if packet["type"] != "storage":
				# If this is a packet generated by the AI (so out) and yet its type in in or its direction is request
				# or for some reason the direction key has been removed from the packet
				# then do not insert this into the outward packets
				if not in_direction and (packet["type"] == "in" or ("direction" in packet and packet["direction"] == "request")):
					continue
			
			out_packet = self.processPacket(packet, instructions)

			if out_packet["type"] == self.configurator.getProperty("MESSAGE_TYPE_CONFIG"):

				self.configurator.update(out_packet)
				out_packet["type"] = self.configurator.getProperty("MESSAGE_TYPE_IN")

			# For now there is only basic setup for each packet

			if out_packet["type"] != self.configurator.getProperty("MESSAGE_TYPE_OUT") and out_packet["type"] != self.configurator.getProperty("MESSAGE_TYPE_RESPONSE"):

				# Only add the numbering id fields if they are not already in the packet

				if "number" not in out_packet:
					current_packet_number += 1
					out_packet["number"] = current_packet_number

				if "group_number" not in out_packet:					
					out_packet["uuid"] = str(uuid.uuid4())
					out_packet["group_number"] = out_packet["uuid"]

				if "ttl" not in out_packet:	
					out_packet["ttl"] = current_packet_ttl

			out_packets.append(out_packet)

		self.configurator.setProperty("PACKET_NUMBER", current_packet_number)

		#print(f"Inside BusinessLogic::checkPackets out_packets = {out_packets}")

		return out_packets